var tipuesearch = {"pages":[{"title":" structblas ","text":"structblas Developer Info Fabio Durastante","tags":"home","loc":"index.html"},{"title":"dcirculant – structblas ","text":"type, public :: dcirculant Contents Variables c isbuild lambda n Type-Bound Procedures build free setc setlambda tomat Source Code dcirculant Components Type Visibility Attributes Name Initial real(kind=real64), public, dimension(:), allocatable :: c logical, public :: isbuild = .false. complex(kind=real64), public, dimension(:), allocatable :: lambda integer(kind=int32), public :: n = -1 Type-Bound Procedures procedure, public, pass(circ) :: build => sb_d_circulant_build interface private module subroutine sb_d_circulant_build(circ, info) If the circulant matrix has c and not lambda builds the latter, if it has lambda \nand not c builds the former Arguments Type Intent Optional Attributes Name class( dcirculant ), intent(inout) :: circ circulant matrix object integer(kind=int32), intent(out) :: info success of the routine procedure, public, pass(circ) :: free => sb_d_circulant_free interface private module subroutine sb_d_circulant_free(circ, info) Free memory occupated by circulant matrix Arguments Type Intent Optional Attributes Name class( dcirculant ), intent(inout) :: circ circulant matrix object integer(kind=int32), intent(out) :: info success of the routine procedure, public, pass(circ) :: setc => sb_d_circulant_setc interface private module subroutine sb_d_circulant_setc(circ, c, info, n) Arguments Type Intent Optional Attributes Name class( dcirculant ), intent(inout) :: circ circulant matrix object real(kind=real64), intent(in), dimension(:) :: c input circulant coefficients integer(kind=int32), intent(out) :: info success of the routine integer(kind=int32), intent(in), optional :: n size of the circulant matrix procedure, public, pass(circ) :: setlambda => sb_d_circulant_setlambda interface private module subroutine sb_d_circulant_setlambda(circ, lambda, info) Implementation that sets the entries of the first column of a circulant matrix Arguments Type Intent Optional Attributes Name class( dcirculant ), intent(inout) :: circ circulant matrix object complex(kind=real64), intent(in), dimension(:) :: lambda input eigenvalues of the circulant matrix integer(kind=int32), intent(out) :: info success of the routine procedure, public, pass(circ) :: tomat => sb_d_circulant_tomat interface private module subroutine sb_d_circulant_tomat(circ, mat, info) Assembles the circulant matrix in the “full” representation Arguments Type Intent Optional Attributes Name class( dcirculant ), intent(in) :: circ circulant matrix object real(kind=real64), intent(inout), allocatable, dimension(:,:) :: mat matrix to be filled integer(kind=int32), intent(out) :: info success of the routine Source Code type :: dcirculant real ( kind = real64 ), dimension (:), allocatable :: c complex ( kind = real64 ), dimension (:), allocatable :: lambda integer ( kind = int32 ) :: n = - 1 logical :: isbuild = . false . contains procedure , pass ( circ ) :: setc => sb_d_circulant_setc procedure , pass ( circ ) :: setlambda => sb_d_circulant_setlambda procedure , pass ( circ ) :: build => sb_d_circulant_build procedure , pass ( circ ) :: tomat => sb_d_circulant_tomat procedure , pass ( circ ) :: free => sb_d_circulant_free end type dcirculant","tags":"","loc":"type/dcirculant.html"},{"title":"libraryinfo – structblas","text":"public subroutine libraryinfo() Uses iso_fortran_env proc~~libraryinfo~~UsesGraph proc~libraryinfo libraryinfo iso_fortran_env iso_fortran_env proc~libraryinfo->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Called by proc~~libraryinfo~~CalledByGraph proc~libraryinfo libraryinfo program~main main program~main->proc~libraryinfo program~helloworld helloworld program~helloworld->proc~libraryinfo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code libraryinfo Source Code subroutine libraryinfo use iso_fortran_env , only : output_unit , compiler_options , compiler_version implicit none write ( output_unit , '(\"Welcome to the STRUCTBLAS library\")' ) write ( output_unit , '(\"This library has been compiled with: \",a)' ) compiler_version () write ( output_unit , '(\"Compiler options are: \",a)' ) compiler_options () end subroutine libraryinfo","tags":"","loc":"proc/libraryinfo.html"},{"title":"sb_gemv – structblas","text":"public interface sb_gemv Calls interface~~sb_gemv~~CallsGraph interface~sb_gemv sb_gemv proc~d_circ_gemv d_circ_gemv interface~sb_gemv->proc~d_circ_gemv fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_1d proc~d_circ_gemv->fftw_plan_dft_r2c_1d fftw_execute_dft_r2c fftw_execute_dft_r2c proc~d_circ_gemv->fftw_execute_dft_r2c fftw_plan_dft_c2r_1d fftw_plan_dft_c2r_1d proc~d_circ_gemv->fftw_plan_dft_c2r_1d fftw_execute_dft_c2r fftw_execute_dft_c2r proc~d_circ_gemv->fftw_execute_dft_c2r proc~sb_toupper sb_toupper proc~d_circ_gemv->proc~sb_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~sb_gemv~~CalledByGraph interface~sb_gemv sb_gemv proc~test_dgemv test_dgemv proc~test_dgemv->interface~sb_gemv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures d_circ_gemv Module Procedures public subroutine d_circ_gemv (trans, alpha, circm, x, beta, y, planf, planb) Computes or Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans real(kind=real64), intent(in) :: alpha type( dcirculant ), intent(inout) :: circm real(kind=real64), intent(inout), dimension(:) :: x real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout), dimension(:) :: y type(c_ptr), intent(inout), optional :: planf type(c_ptr), intent(inout), optional :: planb","tags":"","loc":"interface/sb_gemv.html"},{"title":"d_circ_gemv – structblas","text":"public subroutine d_circ_gemv(trans, alpha, circm, x, beta, y, planf, planb) Uses structblas_util_mod fftw_mod iso_fortran_env iso_c_binding structblas_const_mod proc~~d_circ_gemv~~UsesGraph proc~d_circ_gemv d_circ_gemv module~structblas_const_mod structblas_const_mod proc~d_circ_gemv->module~structblas_const_mod iso_c_binding iso_c_binding proc~d_circ_gemv->iso_c_binding iso_fortran_env iso_fortran_env proc~d_circ_gemv->iso_fortran_env module~structblas_util_mod structblas_util_mod proc~d_circ_gemv->module~structblas_util_mod fftw_mod fftw_mod proc~d_circ_gemv->fftw_mod module~structblas_const_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Computes or Passing a fftw plan to this routine is useful for repeated matrix-vector products\nif you pass it, and the plan is not associated to something after the first\nmatrix vector product the plan is created and can be reused The function checks in case of quick returns: or . If trans = 'T' then If trans = 'N' then Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans real(kind=real64), intent(in) :: alpha type( dcirculant ), intent(inout) :: circm real(kind=real64), intent(inout), dimension(:) :: x real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout), dimension(:) :: y type(c_ptr), intent(inout), optional :: planf type(c_ptr), intent(inout), optional :: planb Calls proc~~d_circ_gemv~~CallsGraph proc~d_circ_gemv d_circ_gemv fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_1d proc~d_circ_gemv->fftw_plan_dft_r2c_1d fftw_execute_dft_r2c fftw_execute_dft_r2c proc~d_circ_gemv->fftw_execute_dft_r2c fftw_plan_dft_c2r_1d fftw_plan_dft_c2r_1d proc~d_circ_gemv->fftw_plan_dft_c2r_1d fftw_execute_dft_c2r fftw_execute_dft_c2r proc~d_circ_gemv->fftw_execute_dft_c2r proc~sb_toupper sb_toupper proc~d_circ_gemv->proc~sb_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~d_circ_gemv~~CalledByGraph proc~d_circ_gemv d_circ_gemv interface~sb_gemv sb_gemv interface~sb_gemv->proc~d_circ_gemv proc~test_dgemv test_dgemv proc~test_dgemv->interface~sb_gemv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/d_circ_gemv.html"},{"title":"sb_toupper – structblas","text":"public pure function sb_toupper(str) result(string) Changes a string to upper case Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Called by proc~~sb_toupper~~CalledByGraph proc~sb_toupper sb_toupper proc~d_circ_gemv d_circ_gemv proc~d_circ_gemv->proc~sb_toupper interface~sb_gemv sb_gemv interface~sb_gemv->proc~d_circ_gemv proc~test_dgemv test_dgemv proc~test_dgemv->interface~sb_gemv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sb_toupper Source Code pure Function sb_toupper ( str ) result ( string ) !! Changes a string to upper case implicit None character ( * ), Intent ( In ) :: str character ( LEN ( str )) :: string integer :: ic , i character ( 26 ), Parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( 26 ), Parameter :: low = 'abcdefghijklmnopqrstuvwxyz' !   Capitalize each letter if it is lowecase string = str do i = 1 , LEN_TRIM ( str ) ic = INDEX ( low , str ( i : i )) if ( ic > 0 ) string ( i : i ) = cap ( ic : ic ) end do end function sb_toupper","tags":"","loc":"proc/sb_toupper.html"},{"title":"test_build_1 – structblas","text":"subroutine test_build_1() Arguments None Calls proc~~test_build_1~~CallsGraph proc~test_build_1 test_build_1 is_equal is_equal proc~test_build_1->is_equal check check proc~test_build_1->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 cvec info n Source Code test_build_1 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: info integer(kind=int32), public :: n Source Code subroutine test_build_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 10 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_build_1","tags":"","loc":"proc/test_build_1.html"},{"title":"test_build_2 – structblas","text":"subroutine test_build_2() Arguments None Calls proc~~test_build_2~~CallsGraph proc~test_build_2 test_build_2 is_equal is_equal proc~test_build_2->is_equal fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_1d proc~test_build_2->fftw_plan_dft_r2c_1d fftw_execute_dft_r2c fftw_execute_dft_r2c proc~test_build_2->fftw_execute_dft_r2c check check proc~test_build_2->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 data_in data_out i info lambda n norm2err planf Source Code test_build_2 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=c_double), public, allocatable :: data_in (:) complex(kind=c_double_complex), public, allocatable :: data_out (:) integer(kind=int32), public :: i integer(kind=int32), public :: info complex(kind=real64), public, dimension(:), allocatable :: lambda integer(kind=int32), public :: n real(kind=real64), public :: norm2err type(c_ptr), public :: planf Source Code subroutine test_build_2 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda real ( kind = real64 ) :: norm2err integer ( kind = int32 ) :: info , n real ( c_double ), allocatable :: data_in (:) complex ( c_double_complex ), allocatable :: data_out (:) integer ( int32 ) :: i type ( c_ptr ) :: planf n = 10 allocate ( data_in ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_in failed\" ) allocate ( data_out ( n / 2 + 1 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_out failed\" ) allocate ( lambda ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate lambda failed\" ) data_in ( 1 : 2 ) = [ 1.0d0 , - 1.0d0 ] planf = fftw_plan_dft_r2c_1d ( size ( data_in ), data_in , data_out , FFTW_ESTIMATE ) call fftw_execute_dft_r2c ( planf , data_in , data_out ) lambda ( 1 : n / 2 + 1 ) = data_out ( 1 : n / 2 + 1 ) lambda ( n / 2 + 2 : n ) = data_out ( n / 2 + 1 : - 1 : 2 ) call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setlambda failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setlambda%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from lambda failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setlambda%c wrong size\" ) norm2err = dzero do i = 1 , n norm2err = norm2err + ( c1 % c ( i ) - data_in ( i )) ** 2 end do norm2err = sqrt ( norm2err ) if ( norm2err . le . 1 d1 * epsilon ( data_in ( 1 ))) then info = structblas_success_ else info = structblas_fail_ end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) deallocate ( data_in , data_out , lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"auxiliary vector free failed\" ) end subroutine test_build_2","tags":"","loc":"proc/test_build_2.html"},{"title":"test_dgemv – structblas","text":"subroutine test_dgemv() Arguments None Calls proc~~test_dgemv~~CallsGraph proc~test_dgemv test_dgemv is_equal is_equal proc~test_dgemv->is_equal interface~sb_gemv sb_gemv proc~test_dgemv->interface~sb_gemv check check proc~test_dgemv->check proc~d_circ_gemv d_circ_gemv interface~sb_gemv->proc~d_circ_gemv fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_1d proc~d_circ_gemv->fftw_plan_dft_r2c_1d fftw_execute_dft_r2c fftw_execute_dft_r2c proc~d_circ_gemv->fftw_execute_dft_r2c fftw_plan_dft_c2r_1d fftw_plan_dft_c2r_1d proc~d_circ_gemv->fftw_plan_dft_c2r_1d fftw_execute_dft_c2r fftw_execute_dft_c2r proc~d_circ_gemv->fftw_execute_dft_c2r proc~sb_toupper sb_toupper proc~d_circ_gemv->proc~sb_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha beta c1 controlmat cvec i info j mat n normfroerr x y z Source Code test_dgemv Variables Type Visibility Attributes Name Initial real(kind=real64), public :: alpha real(kind=real64), public :: beta type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:,:), allocatable :: controlmat real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: i integer(kind=int32), public :: info integer(kind=int32), public :: j real(kind=real64), public, dimension(:,:), allocatable :: mat integer(kind=int32), public :: n real(kind=real32), public :: normfroerr real(kind=real64), public, dimension(:), allocatable :: x real(kind=real64), public, dimension(:), allocatable :: y real(kind=real64), public, dimension(:), allocatable :: z Source Code subroutine test_dgemv () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ) :: alpha , beta real ( kind = real64 ), dimension (:), allocatable :: cvec , x , y , z real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 20 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) allocate ( x ( n ), y ( n ), z ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"x/y/z allocate failed\" ) call random_number ( x ) call random_number ( y ) !call random_number(alpha) !call random_number(beta) alpha = 1.0 beta = 1.0 do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Matrix) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) ! Compute control product z = alpha * matmul ( mat , x ) + beta * y ! Compute real product call sb_gemv ( 'N' , alpha , c1 , x , beta , y ) ! Check the error; normfroerr = dzero do i = 1 , n normfroerr = normfroerr + ( y ( i ) - z ( i )) ** 2 end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Vector) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) deallocate ( cvec , controlmat , x , y , z , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_dgemv","tags":"","loc":"proc/test_dgemv.html"},{"title":"test_setc_1 – structblas","text":"subroutine test_setc_1() Arguments None Calls proc~~test_setc_1~~CallsGraph proc~test_setc_1 test_setc_1 is_equal is_equal proc~test_setc_1->is_equal check check proc~test_setc_1->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 cvec info Source Code test_setc_1 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: info Source Code subroutine test_setc_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc failed\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_1","tags":"","loc":"proc/test_setc_1.html"},{"title":"test_setc_2 – structblas","text":"subroutine test_setc_2() Arguments None Calls proc~~test_setc_2~~CallsGraph proc~test_setc_2 test_setc_2 is_equal is_equal proc~test_setc_2->is_equal check check proc~test_setc_2->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 cvec info n Source Code test_setc_2 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: info integer(kind=int32), public :: n Source Code subroutine test_setc_2 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 5 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_2","tags":"","loc":"proc/test_setc_2.html"},{"title":"test_setc_3 – structblas","text":"subroutine test_setc_3() Arguments None Calls proc~~test_setc_3~~CallsGraph proc~test_setc_3 test_setc_3 is_equal is_equal proc~test_setc_3->is_equal check check proc~test_setc_3->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 cvec info n Source Code test_setc_3 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: info integer(kind=int32), public :: n Source Code subroutine test_setc_3 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 15 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_3","tags":"","loc":"proc/test_setc_3.html"},{"title":"test_setlambda_1 – structblas","text":"subroutine test_setlambda_1() Arguments None Calls proc~~test_setlambda_1~~CallsGraph proc~test_setlambda_1 test_setlambda_1 is_equal is_equal proc~test_setlambda_1->is_equal check check proc~test_setlambda_1->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 i info lambda Source Code test_setlambda_1 Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 integer(kind=int32), public :: i integer(kind=int32), public :: info complex(kind=real64), public, dimension(:), allocatable :: lambda Source Code subroutine test_setlambda_1 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda integer ( kind = int32 ) :: info , i allocate ( lambda ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) do i = 1 , 10 lambda ( i ) = exp ( zunit * i * dpi / 10 ) end do call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % lambda ), 10 ), msg = \"setc%lambda wrong size\" ) deallocate ( lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setlambda_1","tags":"","loc":"proc/test_setlambda_1.html"},{"title":"test_tomat – structblas","text":"subroutine test_tomat() Arguments None Calls proc~~test_tomat~~CallsGraph proc~test_tomat test_tomat is_equal is_equal proc~test_tomat->is_equal check check proc~test_tomat->check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables c1 controlmat cvec i info j mat n normfroerr Source Code test_tomat Variables Type Visibility Attributes Name Initial type( dcirculant ), public :: c1 real(kind=real64), public, dimension(:,:), allocatable :: controlmat real(kind=real64), public, dimension(:), allocatable :: cvec integer(kind=int32), public :: i integer(kind=int32), public :: info integer(kind=int32), public :: j real(kind=real64), public, dimension(:,:), allocatable :: mat integer(kind=int32), public :: n real(kind=real32), public :: normfroerr Source Code subroutine test_tomat () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 5 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ print * , \"mat = \" , mat print * , \"controlmat = \" , controlmat end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_tomat","tags":"","loc":"proc/test_tomat.html"},{"title":"structblas_const_mod – structblas","text":"This module contains the constants  used everywhere in the code.\nInteger constants Uses iso_fortran_env module~~structblas_const_mod~~UsesGraph module~structblas_const_mod structblas_const_mod iso_fortran_env iso_fortran_env module~structblas_const_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~structblas_const_mod~~UsedByGraph module~structblas_const_mod structblas_const_mod proc~d_circ_gemv d_circ_gemv proc~d_circ_gemv->module~structblas_const_mod program~circulant circulant program~circulant->module~structblas_const_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables done dpi dzero structblas_fail_ structblas_success_ zunit Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: done = 1.0d0 real(kind=real64), public, parameter :: dpi = 3.14159265358979323846 real(kind=real64), public, parameter :: dzero = 0.0d0 integer(kind=int32), public, parameter :: structblas_fail_ = 1 Short-hands for numerical constants integer(kind=int32), public, parameter :: structblas_success_ = 0 complex(kind=real64), public, parameter :: zunit = (0.0d0, 1.0d0)","tags":"","loc":"module/structblas_const_mod.html"},{"title":"structblas_mod – structblas","text":"Intrinsic module providing constants, derived types, and intrinsic procedures relating to the Fortran environment.\ngeneral operation interface Uses circulant_mod iso_fortran_env module~~structblas_mod~~UsesGraph module~structblas_mod structblas_mod module~circulant_mod circulant_mod module~structblas_mod->module~circulant_mod iso_fortran_env iso_fortran_env module~structblas_mod->iso_fortran_env module~circulant_mod->iso_fortran_env module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~structblas_mod~~UsedByGraph module~structblas_mod structblas_mod program~fftwinterface fftwinterface program~fftwinterface->module~structblas_mod program~circulant circulant program~circulant->module~structblas_mod program~helloworld helloworld program~helloworld->module~structblas_mod program~main main program~main->module~structblas_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces sb_gemv Subroutines libraryinfo Interfaces public interface sb_gemv public subroutine d_circ_gemv (trans, alpha, circm, x, beta, y, planf, planb) Computes or Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans real(kind=real64), intent(in) :: alpha type( dcirculant ), intent(inout) :: circm real(kind=real64), intent(inout), dimension(:) :: x real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout), dimension(:) :: y type(c_ptr), intent(inout), optional :: planf type(c_ptr), intent(inout), optional :: planb Subroutines public subroutine libraryinfo () Arguments None","tags":"","loc":"module/structblas_mod.html"},{"title":"circulant_mod – structblas","text":"d submodule interfaces Uses structblas_util_mod iso_fortran_env module~~circulant_mod~~UsesGraph module~circulant_mod circulant_mod module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod iso_fortran_env iso_fortran_env module~circulant_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: dcirculant_mod module~~circulant_mod~~UsedByGraph module~circulant_mod circulant_mod module~structblas_mod structblas_mod module~structblas_mod->module~circulant_mod module~dcirculant_mod dcirculant_mod module~dcirculant_mod->module~circulant_mod program~fftwinterface fftwinterface program~fftwinterface->module~structblas_mod program~circulant circulant program~circulant->module~structblas_mod program~helloworld helloworld program~helloworld->module~structblas_mod program~main main program~main->module~structblas_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types dcirculant Subroutines d_circ_gemv Derived Types type, public :: dcirculant Components Type Visibility Attributes Name Initial real(kind=real64), public, dimension(:), allocatable :: c logical, public :: isbuild = .false. complex(kind=real64), public, dimension(:), allocatable :: lambda integer(kind=int32), public :: n = -1 Type-Bound Procedures procedure, public, pass(circ) :: build => sb_d_circulant_build procedure, public, pass(circ) :: free => sb_d_circulant_free procedure, public, pass(circ) :: setc => sb_d_circulant_setc procedure, public, pass(circ) :: setlambda => sb_d_circulant_setlambda procedure, public, pass(circ) :: tomat => sb_d_circulant_tomat Subroutines public subroutine d_circ_gemv (trans, alpha, circm, x, beta, y, planf, planb) Computes or Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans real(kind=real64), intent(in) :: alpha type( dcirculant ), intent(inout) :: circm real(kind=real64), intent(inout), dimension(:) :: x real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout), dimension(:) :: y type(c_ptr), intent(inout), optional :: planf type(c_ptr), intent(inout), optional :: planb","tags":"","loc":"module/circulant_mod.html"},{"title":"structblas_util_mod – structblas","text":"Used by module~~structblas_util_mod~~UsedByGraph module~structblas_util_mod structblas_util_mod proc~d_circ_gemv d_circ_gemv proc~d_circ_gemv->module~structblas_util_mod module~circulant_mod circulant_mod module~circulant_mod->module~structblas_util_mod module~structblas_mod structblas_mod module~structblas_mod->module~circulant_mod module~dcirculant_mod dcirculant_mod module~dcirculant_mod->module~circulant_mod program~fftwinterface fftwinterface program~fftwinterface->module~structblas_mod program~circulant circulant program~circulant->module~structblas_mod program~helloworld helloworld program~helloworld->module~structblas_mod program~main main program~main->module~structblas_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions sb_toupper Functions public pure function sb_toupper (str) result(string) Changes a string to upper case Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character","tags":"","loc":"module/structblas_util_mod.html"},{"title":"dcirculant_mod – structblas","text":"Uses fftw_mod Ancestors: circulant_mod module~~dcirculant_mod~~UsesGraph module~dcirculant_mod dcirculant_mod fftw_mod fftw_mod module~dcirculant_mod->fftw_mod module~circulant_mod circulant_mod module~dcirculant_mod->module~circulant_mod module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod iso_fortran_env iso_fortran_env module~circulant_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/dcirculant_mod.html"},{"title":"fftwinterface – structblas","text":"Uses structblas_mod iso_c_binding iso_fortran_env program~~fftwinterface~~UsesGraph program~fftwinterface fftwinterface module~structblas_mod structblas_mod program~fftwinterface->module~structblas_mod iso_c_binding iso_c_binding program~fftwinterface->iso_c_binding iso_fortran_env iso_fortran_env program~fftwinterface->iso_fortran_env module~structblas_mod->iso_fortran_env module~circulant_mod circulant_mod module~structblas_mod->module~circulant_mod module~circulant_mod->iso_fortran_env module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Source Code fftwinterface Source Code program fftwinterface use iso_fortran_env use iso_c_binding use structblas_mod implicit none end program fftwinterface","tags":"","loc":"program/fftwinterface.html"},{"title":"main – structblas","text":"Uses structblas_mod program~~main~~UsesGraph program~main main module~structblas_mod structblas_mod program~main->module~structblas_mod module~circulant_mod circulant_mod module~structblas_mod->module~circulant_mod iso_fortran_env iso_fortran_env module~structblas_mod->iso_fortran_env module~circulant_mod->iso_fortran_env module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~main~~CallsGraph program~main main proc~libraryinfo libraryinfo program~main->proc~libraryinfo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code main Source Code program main use structblas_mod , only : libraryinfo implicit none call libraryinfo () end program main","tags":"","loc":"program/main.html"},{"title":"circulant – structblas","text":"Uses fftw_mod iso_fortran_env structblas_mod iso_c_binding structblas_const_mod fortuno_serial program~~circulant~~UsesGraph program~circulant circulant iso_c_binding iso_c_binding program~circulant->iso_c_binding fortuno_serial fortuno_serial program~circulant->fortuno_serial module~structblas_const_mod structblas_const_mod program~circulant->module~structblas_const_mod iso_fortran_env iso_fortran_env program~circulant->iso_fortran_env fftw_mod fftw_mod program~circulant->fftw_mod module~structblas_mod structblas_mod program~circulant->module~structblas_mod module~structblas_const_mod->iso_fortran_env module~structblas_mod->iso_fortran_env module~circulant_mod circulant_mod module~structblas_mod->module~circulant_mod module~circulant_mod->iso_fortran_env module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This test program verifies all the routine and functionalities for the circulant matrices. It uses the\nFortuno library for performing unit tests Calls program~~circulant~~CallsGraph program~circulant circulant test test program~circulant->test execute_serial_cmd_app execute_serial_cmd_app program~circulant->execute_serial_cmd_app Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines test_build_1 test_build_2 test_dgemv test_setc_1 test_setc_2 test_setc_3 test_setlambda_1 test_tomat Source Code circulant Subroutines subroutine test_build_1 () Arguments None subroutine test_build_2 () Arguments None subroutine test_dgemv () Arguments None subroutine test_setc_1 () Arguments None subroutine test_setc_2 () Arguments None subroutine test_setc_3 () Arguments None subroutine test_setlambda_1 () Arguments None subroutine test_tomat () Arguments None Source Code program circulant !! This test program verifies all the routine and functionalities for the circulant matrices. It uses the !! Fortuno library for performing unit tests use structblas_mod use structblas_const_mod use iso_fortran_env use iso_c_binding use fftw_mod use fortuno_serial , only : execute_serial_cmd_app , is_equal , test => serial_case_item ,& & check => serial_check implicit none call execute_serial_cmd_app (& testitems = [& test ( \"setc_1\" , test_setc_1 ),& test ( \"setc_2\" , test_setc_2 ),& test ( \"setc_3\" , test_setc_3 ),& test ( \"setlambda_1\" , test_setlambda_1 ),& test ( \"build_1\" , test_build_1 ),& test ( \"build_2\" , test_build_2 ),& test ( \"tomat\" , test_tomat ),& test ( \"dgemv\" , test_dgemv )& ]& ) contains subroutine test_setc_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc failed\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_1 subroutine test_setc_2 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 5 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_2 subroutine test_setc_3 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 15 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_3 subroutine test_setlambda_1 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda integer ( kind = int32 ) :: info , i allocate ( lambda ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) do i = 1 , 10 lambda ( i ) = exp ( zunit * i * dpi / 10 ) end do call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % lambda ), 10 ), msg = \"setc%lambda wrong size\" ) deallocate ( lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setlambda_1 subroutine test_build_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 10 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_build_1 subroutine test_build_2 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda real ( kind = real64 ) :: norm2err integer ( kind = int32 ) :: info , n real ( c_double ), allocatable :: data_in (:) complex ( c_double_complex ), allocatable :: data_out (:) integer ( int32 ) :: i type ( c_ptr ) :: planf n = 10 allocate ( data_in ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_in failed\" ) allocate ( data_out ( n / 2 + 1 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_out failed\" ) allocate ( lambda ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate lambda failed\" ) data_in ( 1 : 2 ) = [ 1.0d0 , - 1.0d0 ] planf = fftw_plan_dft_r2c_1d ( size ( data_in ), data_in , data_out , FFTW_ESTIMATE ) call fftw_execute_dft_r2c ( planf , data_in , data_out ) lambda ( 1 : n / 2 + 1 ) = data_out ( 1 : n / 2 + 1 ) lambda ( n / 2 + 2 : n ) = data_out ( n / 2 + 1 : - 1 : 2 ) call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setlambda failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setlambda%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from lambda failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setlambda%c wrong size\" ) norm2err = dzero do i = 1 , n norm2err = norm2err + ( c1 % c ( i ) - data_in ( i )) ** 2 end do norm2err = sqrt ( norm2err ) if ( norm2err . le . 1 d1 * epsilon ( data_in ( 1 ))) then info = structblas_success_ else info = structblas_fail_ end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) deallocate ( data_in , data_out , lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"auxiliary vector free failed\" ) end subroutine test_build_2 subroutine test_tomat () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 5 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ print * , \"mat = \" , mat print * , \"controlmat = \" , controlmat end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_tomat subroutine test_dgemv () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ) :: alpha , beta real ( kind = real64 ), dimension (:), allocatable :: cvec , x , y , z real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 20 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) allocate ( x ( n ), y ( n ), z ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"x/y/z allocate failed\" ) call random_number ( x ) call random_number ( y ) !call random_number(alpha) !call random_number(beta) alpha = 1.0 beta = 1.0 do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Matrix) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) ! Compute control product z = alpha * matmul ( mat , x ) + beta * y ! Compute real product call sb_gemv ( 'N' , alpha , c1 , x , beta , y ) ! Check the error; normfroerr = dzero do i = 1 , n normfroerr = normfroerr + ( y ( i ) - z ( i )) ** 2 end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Vector) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) deallocate ( cvec , controlmat , x , y , z , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_dgemv end program circulant","tags":"","loc":"program/circulant.html"},{"title":"helloworld – structblas","text":"Uses structblas_mod program~~helloworld~~UsesGraph program~helloworld helloworld module~structblas_mod structblas_mod program~helloworld->module~structblas_mod module~circulant_mod circulant_mod module~structblas_mod->module~circulant_mod iso_fortran_env iso_fortran_env module~structblas_mod->iso_fortran_env module~circulant_mod->iso_fortran_env module~structblas_util_mod structblas_util_mod module~circulant_mod->module~structblas_util_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~helloworld~~CallsGraph program~helloworld helloworld proc~libraryinfo libraryinfo program~helloworld->proc~libraryinfo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code helloworld Source Code program helloworld use structblas_mod implicit none call libraryinfo () end program helloworld","tags":"","loc":"program/helloworld.html"},{"title":"dcirculant_mod.f90 – structblas","text":"This file depends on sourcefile~~dcirculant_mod.f90~~EfferentGraph sourcefile~dcirculant_mod.f90 dcirculant_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules dcirculant_mod Source Code dcirculant_mod.f90 Source Code submodule ( circulant_mod ) dcirculant_mod use fftw_mod implicit none contains subroutine sb_d_circulant_setc ( circ , c , info , n ) !! Implementation that sets the entries of the first column of a circulant matrix use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object real ( kind = real64 ), intent ( in ), dimension (:) :: c !! input circulant coefficients integer ( kind = int32 ), intent ( out ) :: info !! success of the routine integer ( kind = int32 ), intent ( in ), optional :: n !! size of the circulant matrix !! Local variables integer ( kind = int32 ) :: n_ !! size of the circulant matrix integer ( kind = int32 ) :: nonzero !! number of nonzero elements of the circulant matrix info = structblas_success_ if ( present ( n )) then n_ = n else n_ = size ( c ) end if if ( ( n_ . ne . circ % n ). and .( allocated ( circ % lambda ))) then deallocate ( circ % lambda , stat = info ) end if if ( allocated ( circ % c )) then deallocate ( circ % c , stat = info ) end if allocate ( circ % c ( n_ ), stat = info , source = dzero ) nonzero = min ( n_ , size ( c )) circ % c ( 1 : nonzero ) = c ( 1 : nonzero ) circ % n = n_ end subroutine sb_d_circulant_setc subroutine sb_d_circulant_setlambda ( circ , lambda , info ) !! Implementation that sets the entries of the first column of a circulant matrix use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object complex ( kind = real64 ), intent ( in ), dimension (:) :: lambda !! input eigenvalues of the circulant matrix integer ( kind = int32 ), intent ( out ) :: info !! success of the routine !! Local variables integer ( kind = int32 ) :: n_ !! size of the circulant matrix info = structblas_success_ n_ = size ( lambda ) if ( ( n_ . ne . circ % n ). and .( allocated ( circ % c ))) then deallocate ( circ % c , stat = info ) end if if ( allocated ( circ % lambda )) then deallocate ( circ % lambda , stat = info ) end if allocate ( circ % lambda ( n_ ), stat = info ) circ % lambda = lambda circ % n = n_ end subroutine sb_d_circulant_setlambda subroutine sb_d_circulant_build ( circ , info ) !! If the circulant matrix has c and not lambda builds the latter, if it has lambda !! and not c builds the former use iso_fortran_env use fftw_mod use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object integer ( kind = int32 ), intent ( out ) :: info !! success of the routine !! Local variables type ( C_PTR ) :: plan complex ( kind = c_double_complex ), allocatable , dimension (:) :: templambda real ( kind = c_double ), allocatable , dimension (:) :: tempc integer ( kind = int32 ) :: n , ntransform info = structblas_success_ n = circ % n ntransform = n / 2 + 1 if ( allocated ( circ % c ). and .. not . allocated ( circ % lambda )) then !! we have the first column, but we don't have the eigenvalues allocate ( circ % lambda ( n ), templambda ( ntransform ), tempc ( n ), stat = info ) plan = fftw_plan_dft_r2c_1d ( n , tempc , templambda , FFTW_ESTIMATE ) tempc ( 1 : n ) = circ % c ( 1 : n ) call fftw_execute_dft_r2c ( plan , tempc , templambda ) circ % lambda ( 1 : ntransform ) = templambda !/sqrt(real(n)) circ % lambda ( ntransform + 1 : n ) = conjg ( templambda ( ntransform : 2 : - 1 )) / sqrt ( real ( n )) call fftw_destroy_plan ( plan ) deallocate ( templambda , tempc , stat = info ) circ % isbuild = . true . else if ( allocated ( circ % lambda ). and .. not . allocated ( circ % c )) then !! we have the eigenvalues, but we don't have the first column allocate ( circ % c ( n ), templambda ( ntransform ), tempc ( n ), stat = info ) plan = fftw_plan_dft_c2r_1d ( n , templambda , tempc , FFTW_ESTIMATE ) templambda ( 1 : ntransform ) = circ % lambda ( 1 : ntransform ) call fftw_execute_dft_c2r ( plan , templambda , tempc ) circ % c ( 1 : n ) = tempc ( 1 : n ) / real ( n ) call fftw_destroy_plan ( plan ) deallocate ( templambda , tempc , stat = info ) circ % isbuild = . true . end if end subroutine sb_d_circulant_build subroutine sb_d_circulant_tomat ( circ , mat , info ) !! Assembles the circulant matrix in the \"full\" representation use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( in ) :: circ !! circulant matrix object real ( kind = real64 ), allocatable , dimension (:,:), intent ( inout ) :: mat !! matrix to be filled integer ( kind = int32 ), intent ( out ) :: info !! success of the routine !! Local variables integer ( kind = int32 ) :: i , j info = structblas_success_ if (. not . allocated ( circ % c )) then info = structblas_fail_ return end if allocate ( mat ( circ % n , circ % n ), stat = info ) do i = 0 , circ % n - 1 do j = 0 , circ % n - 1 mat ( i + 1 , j + 1 ) = circ % c ( modulo ( i - j , circ % n ) + 1 ) end do end do end subroutine sb_d_circulant_tomat subroutine sb_d_circulant_free ( circ , info ) !! Free memory occupated by circulant matrix use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object integer ( kind = int32 ), intent ( out ) :: info !! success of the routine info = structblas_success_ if ( allocated ( circ % c )) deallocate ( circ % c , stat = info ) if ( allocated ( circ % lambda )) deallocate ( circ % lambda , stat = info ) circ % n = - 1 circ % isbuild = . false . end subroutine end submodule dcirculant_mod","tags":"","loc":"sourcefile/dcirculant_mod.f90.html"},{"title":"structblas_const_mod.f90 – structblas","text":"Files dependent on this one sourcefile~~structblas_const_mod.f90~~AfferentGraph sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 sourcefile~dcirculant_mod.f90 dcirculant_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~structblas_const_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~circulant_mod.f90 sourcefile~circulant.f90 circulant.f90 sourcefile~circulant.f90->sourcefile~structblas_const_mod.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~circulant.f90->sourcefile~structblas_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~fftwinterface.f90 fftwinterface.f90 sourcefile~fftwinterface.f90->sourcefile~structblas_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~structblas_mod.f90 sourcefile~helloworld.f90 helloworld.f90 sourcefile~helloworld.f90->sourcefile~structblas_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules structblas_const_mod Source Code structblas_const_mod.f90 Source Code module structblas_const_mod !! This module contains the constants  used everywhere in the code. use iso_fortran_env implicit none !! Integer constants integer ( kind = int32 ), parameter :: structblas_success_ = 0 integer ( kind = int32 ), parameter :: structblas_fail_ = 1 !! Short-hands for numerical constants real ( kind = real64 ), parameter :: dzero = 0.0d0 real ( kind = real64 ), parameter :: done = 1.0d0 complex ( kind = real64 ), parameter :: zunit = ( 0.0d0 , 1.0d0 ) real ( kind = real64 ), parameter :: dpi = 3.14159265358979323846 end module","tags":"","loc":"sourcefile/structblas_const_mod.f90.html"},{"title":"structblas_mod.f90 – structblas","text":"This file depends on sourcefile~~structblas_mod.f90~~EfferentGraph sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~structblas_mod.f90~~AfferentGraph sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~fftwinterface.f90 fftwinterface.f90 sourcefile~fftwinterface.f90->sourcefile~structblas_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~structblas_mod.f90 sourcefile~helloworld.f90 helloworld.f90 sourcefile~helloworld.f90->sourcefile~structblas_mod.f90 sourcefile~circulant.f90 circulant.f90 sourcefile~circulant.f90->sourcefile~structblas_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules structblas_mod Source Code structblas_mod.f90 Source Code module structblas_mod use iso_fortran_env !! Intrinsic module providing constants, derived types, and intrinsic procedures relating to the Fortran environment. use circulant_mod implicit none !! general operation interface interface sb_gemv module procedure d_circ_gemv end interface sb_gemv contains subroutine libraryinfo use iso_fortran_env , only : output_unit , compiler_options , compiler_version implicit none write ( output_unit , '(\"Welcome to the STRUCTBLAS library\")' ) write ( output_unit , '(\"This library has been compiled with: \",a)' ) compiler_version () write ( output_unit , '(\"Compiler options are: \",a)' ) compiler_options () end subroutine libraryinfo end module structblas_mod","tags":"","loc":"sourcefile/structblas_mod.f90.html"},{"title":"circulant_mod.f90 – structblas","text":"This file depends on sourcefile~~circulant_mod.f90~~EfferentGraph sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~circulant_mod.f90~~AfferentGraph sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~dcirculant_mod.f90 dcirculant_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~fftwinterface.f90 fftwinterface.f90 sourcefile~fftwinterface.f90->sourcefile~structblas_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~structblas_mod.f90 sourcefile~helloworld.f90 helloworld.f90 sourcefile~helloworld.f90->sourcefile~structblas_mod.f90 sourcefile~circulant.f90 circulant.f90 sourcefile~circulant.f90->sourcefile~structblas_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules circulant_mod Source Code circulant_mod.f90 Source Code module circulant_mod use iso_fortran_env use structblas_util_mod implicit none private type :: dcirculant real ( kind = real64 ), dimension (:), allocatable :: c complex ( kind = real64 ), dimension (:), allocatable :: lambda integer ( kind = int32 ) :: n = - 1 logical :: isbuild = . false . contains procedure , pass ( circ ) :: setc => sb_d_circulant_setc procedure , pass ( circ ) :: setlambda => sb_d_circulant_setlambda procedure , pass ( circ ) :: build => sb_d_circulant_build procedure , pass ( circ ) :: tomat => sb_d_circulant_tomat procedure , pass ( circ ) :: free => sb_d_circulant_free end type dcirculant !! d submodule interfaces interface module subroutine sb_d_circulant_setc ( circ , c , info , n ) use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object real ( kind = real64 ), intent ( in ), dimension (:) :: c !! input circulant coefficients integer ( kind = int32 ), intent ( out ) :: info !! success of the routine integer ( kind = int32 ), intent ( in ), optional :: n !! size of the circulant matrix end subroutine sb_d_circulant_setc end interface interface module subroutine sb_d_circulant_setlambda ( circ , lambda , info ) !! Implementation that sets the entries of the first column of a circulant matrix use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object complex ( kind = real64 ), intent ( in ), dimension (:) :: lambda !! input eigenvalues of the circulant matrix integer ( kind = int32 ), intent ( out ) :: info !! success of the routine end subroutine sb_d_circulant_setlambda end interface interface module subroutine sb_d_circulant_build ( circ , info ) !! If the circulant matrix has c and not lambda builds the latter, if it has lambda !! and not c builds the former use iso_fortran_env use iso_c_binding use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object integer ( kind = int32 ), intent ( out ) :: info !! success of the routine end subroutine sb_d_circulant_build end interface interface module subroutine sb_d_circulant_tomat ( circ , mat , info ) !! Assembles the circulant matrix in the \"full\" representation use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( in ) :: circ !! circulant matrix object real ( kind = real64 ), allocatable , dimension (:,:), intent ( inout ) :: mat !! matrix to be filled integer ( kind = int32 ), intent ( out ) :: info !! success of the routine end subroutine sb_d_circulant_tomat end interface interface module subroutine sb_d_circulant_free ( circ , info ) !! Free memory occupated by circulant matrix use iso_fortran_env use structblas_const_mod implicit none class ( dcirculant ), intent ( inout ) :: circ !! circulant matrix object integer ( kind = int32 ), intent ( out ) :: info !! success of the routine end subroutine sb_d_circulant_free end interface public :: dcirculant , d_circ_gemv contains subroutine d_circ_gemv ( trans , alpha , circm , x , beta , y , planf , planb ) !! Computes  \\mathbf{y} = \\alpha C \\mathbf{x} + \\beta \\mathbf{y}  or  \\mathbf{y} = \\alpha C&#94;T \\mathbf{x} + \\beta \\mathbf{y}  use iso_fortran_env use iso_c_binding use structblas_const_mod use structblas_util_mod use fftw_mod implicit none character ( len = 1 ), intent ( in ) :: trans real ( kind = real64 ), intent ( in ) :: alpha type ( dcirculant ), intent ( inout ) :: circm real ( kind = real64 ), intent ( inout ), dimension (:) :: x real ( kind = real64 ), intent ( in ) :: beta real ( kind = real64 ), intent ( inout ), dimension (:) :: y type ( c_ptr ), intent ( inout ), optional :: planf , planb ! Local variables integer ( kind = int32 ) :: info , n , i complex ( kind = c_double_complex ), dimension (:), allocatable :: forwardvec real ( kind = c_double ), dimension (:), allocatable :: backvec logical :: wehaveaplan type ( c_ptr ) :: planf_ , planb_ ! Check inputs if (. not . circm % isbuild ) then if ( allocated ( circm % c ). or . allocated ( circm % lambda )) then call circm % build ( info ) else write ( error_unit , '(\"d_circ_genmv: circm is empty\")' ) return end if else n = circm % n if (( n /= size ( x )). or .( n /= size ( y ))) then write ( error_unit , '(\"d_circ_genmv: circm, x, y sizes are not compatible\")' ) return end if end if if ( present ( planf ). and . present ( planb )) then !! !! Passing a fftw plan to this routine is useful for repeated matrix-vector products !! if you pass it, and the plan is not associated to something after the first !! matrix vector product the plan is created and can be reused !! if ( c_associated ( planf ). and . c_associated ( planb )) then planf_ = planf planb_ = planb wehaveaplan = . true . else wehaveaplan = . false . end if else wehaveaplan = . false . end if !! !! The function checks in case of quick returns:  n = 0  or  \\alpha =0 \\land \\beta = 0 . !! if (( n . eq . 0 ). or .(( alpha . eq . dzero ). and .( beta . eq . done ))) return allocate ( forwardvec ( n / 2 + 1 ), stat = info ) allocate ( backvec ( n ), stat = info ) if (( beta /= done ). and .( beta /= dzero )) y = beta * y select case ( sb_toupper ( trans )) case ( 'T' ) !! !! If `trans = 'T'` then  \\mathbf{y} = \\alpha C&#94;T \\mathbf{x} + \\beta \\mathbf{y}  !! ! if (.not.wehaveaplan) then !     !! We don't have a plan and we have to generate them !     planf_ = fftw_plan_dft_r2c_1d(n,x,forwardvec,FFTW_MEASURE) !     planb_ = fftw_plan_dft_r2c_1d(n,forwardvec,backvec,FFTW_MEASURE) ! end if ! !! We have FFTWs plan and we can just perform multiplications ! call fftw_execute_dft_r2c(planf_,x,forwardvec) ! do i=1,n/2+1 !     forwardvec(i) = alpha*forwardvec(i)*circm%lambda(i) ! end do ! call fftw_execute_dft_c2r(planb_,forwardvec,backvec) ! y = backvec + x case ( 'N' ) !! !! If `trans = 'N'` then  \\mathbf{y} = \\alpha C \\mathbf{x} + \\beta \\mathbf{y}  !! if (. not . wehaveaplan ) then ! We don't have a plan and we have to generate them planf_ = fftw_plan_dft_r2c_1d ( n , backvec , forwardvec , FFTW_MEASURE ) planb_ = fftw_plan_dft_c2r_1d ( n , forwardvec , backvec , FFTW_MEASURE ) end if ! We have FFTWs plan and we can just perform multiplications call fftw_execute_dft_r2c ( planf_ , x , forwardvec ) ! write(output_unit,*) \"fft(x) = \", forwardvec do i = 1 , n / 2 + 1 forwardvec ( i ) = forwardvec ( i ) * circm % lambda ( i ) end do call fftw_execute_dft_c2r ( planb_ , forwardvec , backvec ) y = alpha * backvec / real ( n ) + y case default write ( error_unit , '(\"d_circ_genmv: unknown transpose/non-transpose charachter\")' ) deallocate ( forwardvec , stat = info ) deallocate ( backvec , stat = info ) return end select deallocate ( forwardvec , stat = info ) deallocate ( backvec , stat = info ) end subroutine end module circulant_mod","tags":"","loc":"sourcefile/circulant_mod.f90.html"},{"title":"structblas_util_mod.f90 – structblas","text":"Files dependent on this one sourcefile~~structblas_util_mod.f90~~AfferentGraph sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~dcirculant_mod.f90 dcirculant_mod.f90 sourcefile~dcirculant_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~fftwinterface.f90 fftwinterface.f90 sourcefile~fftwinterface.f90->sourcefile~structblas_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~structblas_mod.f90 sourcefile~helloworld.f90 helloworld.f90 sourcefile~helloworld.f90->sourcefile~structblas_mod.f90 sourcefile~circulant.f90 circulant.f90 sourcefile~circulant.f90->sourcefile~structblas_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules structblas_util_mod Source Code structblas_util_mod.f90 Source Code module structblas_util_mod private public :: sb_toupper contains pure Function sb_toupper ( str ) result ( string ) !! Changes a string to upper case implicit None character ( * ), Intent ( In ) :: str character ( LEN ( str )) :: string integer :: ic , i character ( 26 ), Parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( 26 ), Parameter :: low = 'abcdefghijklmnopqrstuvwxyz' !   Capitalize each letter if it is lowecase string = str do i = 1 , LEN_TRIM ( str ) ic = INDEX ( low , str ( i : i )) if ( ic > 0 ) string ( i : i ) = cap ( ic : ic ) end do end function sb_toupper end module structblas_util_mod","tags":"","loc":"sourcefile/structblas_util_mod.f90.html"},{"title":"fftwinterface.f90 – structblas","text":"This file depends on sourcefile~~fftwinterface.f90~~EfferentGraph sourcefile~fftwinterface.f90 fftwinterface.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~fftwinterface.f90->sourcefile~structblas_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs fftwinterface Source Code fftwinterface.f90 Source Code program fftwinterface use iso_fortran_env use iso_c_binding use structblas_mod implicit none end program fftwinterface","tags":"","loc":"sourcefile/fftwinterface.f90.html"},{"title":"main.f90 – structblas","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~main.f90->sourcefile~structblas_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs main Source Code main.f90 Source Code program main use structblas_mod , only : libraryinfo implicit none call libraryinfo () end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"circulant.f90 – structblas","text":"This file depends on sourcefile~~circulant.f90~~EfferentGraph sourcefile~circulant.f90 circulant.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~circulant.f90->sourcefile~structblas_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant.f90->sourcefile~structblas_const_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs circulant Source Code circulant.f90 Source Code program circulant !! This test program verifies all the routine and functionalities for the circulant matrices. It uses the !! Fortuno library for performing unit tests use structblas_mod use structblas_const_mod use iso_fortran_env use iso_c_binding use fftw_mod use fortuno_serial , only : execute_serial_cmd_app , is_equal , test => serial_case_item ,& & check => serial_check implicit none call execute_serial_cmd_app (& testitems = [& test ( \"setc_1\" , test_setc_1 ),& test ( \"setc_2\" , test_setc_2 ),& test ( \"setc_3\" , test_setc_3 ),& test ( \"setlambda_1\" , test_setlambda_1 ),& test ( \"build_1\" , test_build_1 ),& test ( \"build_2\" , test_build_2 ),& test ( \"tomat\" , test_tomat ),& test ( \"dgemv\" , test_dgemv )& ]& ) contains subroutine test_setc_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc failed\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_1 subroutine test_setc_2 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 5 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_2 subroutine test_setc_3 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 15 allocate ( cvec ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setc_3 subroutine test_setlambda_1 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda integer ( kind = int32 ) :: info , i allocate ( lambda ( 10 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) do i = 1 , 10 lambda ( i ) = exp ( zunit * i * dpi / 10 ) end do call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % lambda ), 10 ), msg = \"setc%lambda wrong size\" ) deallocate ( lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_setlambda_1 subroutine test_build_1 () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec integer ( kind = int32 ) :: info , n n = 10 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate failed\" ) cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_build_1 subroutine test_build_2 () implicit none type ( dcirculant ) :: c1 complex ( kind = real64 ), dimension (:), allocatable :: lambda real ( kind = real64 ) :: norm2err integer ( kind = int32 ) :: info , n real ( c_double ), allocatable :: data_in (:) complex ( c_double_complex ), allocatable :: data_out (:) integer ( int32 ) :: i type ( c_ptr ) :: planf n = 10 allocate ( data_in ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_in failed\" ) allocate ( data_out ( n / 2 + 1 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate data_out failed\" ) allocate ( lambda ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"allocate lambda failed\" ) data_in ( 1 : 2 ) = [ 1.0d0 , - 1.0d0 ] planf = fftw_plan_dft_r2c_1d ( size ( data_in ), data_in , data_out , FFTW_ESTIMATE ) call fftw_execute_dft_r2c ( planf , data_in , data_out ) lambda ( 1 : n / 2 + 1 ) = data_out ( 1 : n / 2 + 1 ) lambda ( n / 2 + 2 : n ) = data_out ( n / 2 + 1 : - 1 : 2 ) call c1 % setlambda ( lambda , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"setlambda failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setlambda%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from lambda failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setlambda%c wrong size\" ) norm2err = dzero do i = 1 , n norm2err = norm2err + ( c1 % c ( i ) - data_in ( i )) ** 2 end do norm2err = sqrt ( norm2err ) if ( norm2err . le . 1 d1 * epsilon ( data_in ( 1 ))) then info = structblas_success_ else info = structblas_fail_ end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) deallocate ( data_in , data_out , lambda , stat = info ) call check ( is_equal ( info , 0 ), msg = \"auxiliary vector free failed\" ) end subroutine test_build_2 subroutine test_tomat () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ), dimension (:), allocatable :: cvec real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 5 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ print * , \"mat = \" , mat print * , \"controlmat = \" , controlmat end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) deallocate ( cvec , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_tomat subroutine test_dgemv () implicit none type ( dcirculant ) :: c1 real ( kind = real64 ) :: alpha , beta real ( kind = real64 ), dimension (:), allocatable :: cvec , x , y , z real ( kind = real64 ), dimension (:,:), allocatable :: mat , controlmat real ( kind = real32 ) :: normfroerr integer ( kind = int32 ) :: info , n , i , j n = 20 allocate ( cvec ( 2 ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"cvec allocate failed\" ) allocate ( controlmat ( n , n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"controlmat allocate failed\" ) allocate ( x ( n ), y ( n ), z ( n ), stat = info ) call check ( is_equal ( info , 0 ), msg = \"x/y/z allocate failed\" ) call random_number ( x ) call random_number ( y ) !call random_number(alpha) !call random_number(beta) alpha = 1.0 beta = 1.0 do i = 1 , n do j = 1 , n if ( i - j == 1 ) then controlmat ( i , j ) = - done else if ( i == j ) then controlmat ( i , j ) = done else controlmat ( i , j ) = dzero end if end do end do controlmat ( 1 , n ) = - done cvec = [ 1 , - 1 ] call c1 % setc ( cvec , info , n = n ) call check ( is_equal ( info , structblas_success_ ), msg = \"setc with n failed\" ) call check ( is_equal ( size ( c1 % c ), n ), msg = \"setc%c wrong size\" ) call c1 % build ( info ) call check ( is_equal ( info , structblas_success_ ), msg = \"build from c failed\" ) call check ( is_equal ( size ( c1 % lambda ), n ), msg = \"setc%lambda wrong size\" ) call c1 % tomat ( mat , info ) call check ( is_equal ( info , structblas_success_ ), msg = \"tomat failed\" ) normfroerr = dzero do i = 1 , n do j = 1 , n normfroerr = normfroerr + ( mat ( i , j ) - controlmat ( i , j )) ** 2 end do end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Matrix) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong matrix reconstruction\" ) ! Compute control product z = alpha * matmul ( mat , x ) + beta * y ! Compute real product call sb_gemv ( 'N' , alpha , c1 , x , beta , y ) ! Check the error; normfroerr = dzero do i = 1 , n normfroerr = normfroerr + ( y ( i ) - z ( i )) ** 2 end do normfroerr = sqrt ( normfroerr ) if ( normfroerr . le . 1 d1 * epsilon ( cvec ( 1 ))) then info = structblas_success_ else info = structblas_fail_ write ( output_unit , '(\"(Vector) Error is \",E16.5)' ) normfroerr end if call check ( is_equal ( info , structblas_success_ ), msg = \"wrong vector reconstruction\" ) deallocate ( cvec , controlmat , x , y , z , stat = info ) call check ( is_equal ( info , 0 ), msg = \"deallocate failed\" ) call c1 % free ( info ) call check ( is_equal ( info , 0 ), msg = \"circulant free failed\" ) end subroutine test_dgemv end program circulant","tags":"","loc":"sourcefile/circulant.f90.html"},{"title":"helloworld.f90 – structblas","text":"This file depends on sourcefile~~helloworld.f90~~EfferentGraph sourcefile~helloworld.f90 helloworld.f90 sourcefile~structblas_mod.f90 structblas_mod.f90 sourcefile~helloworld.f90->sourcefile~structblas_mod.f90 sourcefile~circulant_mod.f90 circulant_mod.f90 sourcefile~structblas_mod.f90->sourcefile~circulant_mod.f90 sourcefile~structblas_util_mod.f90 structblas_util_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_util_mod.f90 sourcefile~structblas_const_mod.f90 structblas_const_mod.f90 sourcefile~circulant_mod.f90->sourcefile~structblas_const_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs helloworld Source Code helloworld.f90 Source Code program helloworld use structblas_mod implicit none call libraryinfo () end program helloworld","tags":"","loc":"sourcefile/helloworld.f90.html"},{"title":"Documentation – structblas","text":"Documentation Understanding BLAS Operations Introduction BLAS (Basic Linear Algebra Subprograms) are a set of routines that provide standard building blocks for performing basic vector and matrix operations. These operations form the backbone of many numerical and scientific computing libraries. This document aims to explain the fundamentals of BLAS operations, their categorization, and their significance in computational mathematics. Categorization of BLAS Operations BLAS operations are categorized into three levels based on their complexity and generality: Level 1 BLAS Level 1 BLAS operations primarily involve vector-vector operations. These operations are relatively simple and include tasks such as vector addition, scalar-vector multiplication, dot product, and vector norms. Level 2 BLAS Level 2 BLAS operations involve matrix-vector operations. These operations are slightly more complex and include tasks such as matrix-vector multiplication and solving triangular systems of linear equations. Level 3 BLAS Level 3 BLAS operations involve matrix-matrix operations. These operations are the most complex and computationally intensive, including tasks such as matrix-matrix multiplication and solving systems of linear equations with multiple right-hand sides. Significance of BLAS Operations BLAS operations are fundamental to many scientific and numerical computing tasks due to the following reasons: Efficiency : BLAS routines are highly optimized for performance, often utilizing hardware-specific features such as SIMD (Single Instruction, Multiple Data) instructions and parallelization techniques to achieve maximum efficiency. Portability : BLAS routines provide a standardized interface for common linear algebra operations, allowing software developers to write code that can be easily ported across different hardware architectures and platforms. Interoperability : Many numerical and scientific computing libraries, such as LAPACK , PSCToolkit , and NumPy , are built on top of BLAS routines, ensuring interoperability between different software packages and facilitating code reuse. Scalability : BLAS operations are designed to scale efficiently with problem size, making them suitable for large-scale scientific computing tasks such as numerical simulations, data analysis, and machine learning. Example BLAS Operations Level 1 BLAS Operations Vector Addition : Scalar-Vector Multiplication : Dot Product : Vector Norm : Level 2 BLAS Operations Matrix-Vector Multiplication : Solving Triangular Systems : or Level 3 BLAS Operations Matrix-Matrix Multiplication : Solving Systems with Multiple Right-Hand Sides : or Conclusion BLAS operations form the foundation of many numerical and scientific computing tasks, providing efficient and standardized routines for basic linear algebra operations. Understanding the categorization and significance of BLAS operations is essential for developing efficient and portable numerical software and for leveraging the capabilities of modern hardware architectures.","tags":"","loc":"page/index.html"},{"title":"Circulant Matrices – structblas","text":"Circulant Matrices Introduction Circulant matrices are a special class of matrices in linear algebra that exhibit certain unique properties. They are defined by their circulant structure, where each row of the matrix is a circular shift of the previous row. This document aims to provide an explanation of circulant matrices, their properties, and some applications. Definition A circulant matrix is a square matrix in which each row is a cyclic permutation of the previous row, with the last entry of each row becoming the first entry in the next row. Mathematically, a circulant matrix of size can be represented as: Where represents the elements of the first row of the matrix. Properties Eigenvalues : Circulant matrices have a special property concerning their eigenvalues. If is a circulant matrix with first row , then its eigenvalues are given by: Where for . Fast Multiplication : Circulant matrices have a fast multiplication property. Multiplying a circulant matrix with a vector can be done efficiently in operations using the Fast Fourier Transform (FFT) algorithm. Shift Invariance : Circulant matrices are shift-invariant, meaning that shifting the rows or columns of the matrix does not change its structure or properties. Convolution : Circulant matrices are closely related to convolution operations in signal processing. Multiplication of a circulant matrix by a vector is equivalent to convolution of the vector with the first row of the circulant matrix. Applications Signal Processing : Circulant matrices find extensive use in signal processing applications due to their connection with convolution operations. They are employed in filtering, image processing, and spectral analysis. Error Correction Codes : Circulant matrices are utilized in error correction coding schemes, such as Reed-Solomon codes, for efficient encoding and decoding processes. Numerical Analysis : Circulant matrices are often employed in numerical analysis for solving systems of linear equations and in various iterative methods due to their special properties that allow for efficient computations. Quantum Computing : Circulant matrices have applications in quantum computing algorithms, particularly in quantum signal processing tasks and quantum simulations. Conclusion Circulant matrices are a fascinating class of matrices with unique properties that make them valuable in various fields such as signal processing, error correction coding, numerical analysis, and quantum computing. Understanding their properties and applications can lead to efficient algorithms and solutions in these domains.","tags":"","loc":"page/circulant.html"}]}